# FastExplorer パフォーマンス改善まとめ

このドキュメントは、`.specstory/history`フォルダー内のmdファイルから、パフォーマンス改善に関するやり取りをまとめたものです。

## 目次

1. [ファイルシステム操作の最適化](#ファイルシステム操作の最適化)
2. [UI応答性の改善](#ui応答性の改善)
3. [起動時のパフォーマンス改善](#起動時のパフォーマンス改善)
4. [メモリとキャッシュの最適化](#メモリとキャッシュの最適化)
5. [ビジュアルツリー走査の最適化](#ビジュアルツリー走査の最適化)
6. [その他の最適化](#その他の最適化)

---

## ファイルシステム操作の最適化

### FileSystemService.GetItems()の最適化
**日付**: 2025-11-16

**問題点**:
- `Directory.GetDirectories()`と`Directory.GetFiles()`を別々に呼び出していた
- ディレクトリとファイルを2回列挙していた

**改善内容**:
- `DirectoryInfo.EnumerateFileSystemInfos()`を使用して一度に取得
- `EnumerationOptions`でアクセス不可ファイルをスキップ
- ソートに`StringComparer.OrdinalIgnoreCase`を使用

**コード変更例**:

**変更前**:
```csharp
// ディレクトリを先に追加
var directories = Directory.GetDirectories(path);
foreach (var dir in directories)
{
    var dirInfo = new DirectoryInfo(dir);
    items.Add(new FileSystemItem
    {
        Name = dirInfo.Name,
        FullPath = dirInfo.FullName,
        // ...
    });
}

// ファイルを追加
var files = Directory.GetFiles(path);
foreach (var file in files)
{
    var fileInfo = new FileInfo(file);
    items.Add(new FileSystemItem
    {
        Name = fileInfo.Name,
        // ...
    });
}

return items.OrderByDescending(x => x.IsDirectory).ThenBy(x => x.Name);
```

**変更後**:
```csharp
var dirInfo = new DirectoryInfo(path);

// EnumerateFileSystemInfosを使用してディレクトリとファイルを一度に取得
foreach (var info in dirInfo.EnumerateFileSystemInfos("*", new EnumerationOptions
{
    IgnoreInaccessible = true,
    ReturnSpecialDirectories = false
}))
{
    var isDirectory = (info.Attributes & FileAttributes.Directory) == FileAttributes.Directory;
    long size = 0;
    
    if (!isDirectory && info is FileInfo fileInfo)
    {
        size = fileInfo.Length;
    }
    
    items.Add(new FileSystemItem
    {
        Name = info.Name,
        FullPath = info.FullName,
        Extension = isDirectory ? string.Empty : info.Extension,
        Size = size,
        LastModified = info.LastWriteTime,
        IsDirectory = isDirectory,
        Attributes = info.Attributes
    });
}

return items.OrderByDescending(x => x.IsDirectory)
    .ThenBy(x => x.Name, StringComparer.OrdinalIgnoreCase);
```

**効果**:
- ファイルシステム操作の効率化
- 不要な`DirectoryInfo`/`FileInfo`オブジェクトの作成を削減

---

## UI応答性の改善

### ExplorerViewModel.NavigateToDirectory()の非同期化
**日付**: 2025-11-16

**問題点**:
- ファイル一覧の取得が同期的で、UIスレッドをブロックしていた
- 大量ファイル時にUIがフリーズしていた

**改善内容**:
- ファイル一覧の取得をバックグラウンドスレッドで実行
- バッチ更新（200件ずつ）でUIの応答性を維持
- キャンセレーショントークンで、新しいナビゲーション開始時に前の処理をキャンセル

**コード変更例**:

**変更前**:
```csharp
public void NavigateToDirectory(string path, bool addToHistory = true)
{
    // ...
    Items.Clear();
    IsLoading = true;
    
    try
    {
        var fileItems = _fileSystemService.GetItems(path);
        foreach (var item in fileItems)
        {
            Items.Add(item);
        }
    }
    catch (Exception)
    {
        // エラーハンドリング
    }
    finally
    {
        IsLoading = false;
        _isNavigating = false;
    }
}
```

**変更後**:
```csharp
private CancellationTokenSource? _navigationCancellationTokenSource;

public void NavigateToDirectory(string path, bool addToHistory = true)
{
    // ...
    Items.Clear();
    IsLoading = true;
    
    // 前のナビゲーションをキャンセル
    _navigationCancellationTokenSource?.Cancel();
    _navigationCancellationTokenSource?.Dispose();
    _navigationCancellationTokenSource = new CancellationTokenSource();
    var cancellationToken = _navigationCancellationTokenSource.Token;
    
    // 非同期でファイル一覧を読み込み（UIスレッドをブロックしない）
    _ = Task.Run(async () =>
    {
        try
        {
            var fileItems = _fileSystemService.GetItems(path);
            var itemList = new List<FileSystemItem>(256);
            foreach (var item in fileItems)
            {
                if (cancellationToken.IsCancellationRequested)
                    return;
                itemList.Add(item);
            }
            
            // UIスレッドでバッチ更新（200件ずつ）
            const int batchSize = 200;
            var dispatcher = System.Windows.Application.Current?.Dispatcher;
            if (dispatcher == null)
                return;
            
            if (itemList.Count <= batchSize)
            {
                await dispatcher.InvokeAsync(() =>
                {
                    if (!cancellationToken.IsCancellationRequested)
                    {
                        foreach (var item in itemList)
                        {
                            Items.Add(item);
                        }
                    }
                });
            }
            else
            {
                // 大量の場合はバッチ更新
                for (int i = 0; i < itemList.Count; i += batchSize)
                {
                    if (cancellationToken.IsCancellationRequested)
                        return;
                    
                    var batch = itemList.Skip(i).Take(batchSize).ToList();
                    await dispatcher.InvokeAsync(() =>
                    {
                        if (!cancellationToken.IsCancellationRequested)
                        {
                            foreach (var item in batch)
                            {
                                Items.Add(item);
                            }
                        }
                    });
                }
            }
        }
        catch (Exception)
        {
            // エラーハンドリング
        }
        finally
        {
            if (!cancellationToken.IsCancellationRequested)
            {
                dispatcher?.Invoke(() =>
                {
                    IsLoading = false;
                    _isNavigating = false;
                });
            }
        }
    }, cancellationToken);
}
```

**効果**:
- UIスレッドのブロックを防止
- 大量ファイルでもUIがフリーズしない

### ExplorerViewModel.LoadDrives()の非同期化
**日付**: 2025-11-20

**問題点**:
- ドライブ情報取得が同期的で、ネットワークドライブがあるとUIスレッドがブロックされる

**改善内容**:
- `LoadDrivesAsync()`に変更し、バックグラウンドで取得
- ネットワークドライブの応答待ちでUIスレッドをブロックしない

**コード変更例**:

**変更前**:
```csharp
public void NavigateToHome()
{
    // ...
    try
    {
        // ピン留めフォルダーを読み込み
        LoadPinnedFolders();
        
        // ドライブ情報を読み込み（同期的、ネットワークドライブでブロックされる）
        LoadDrives();
        
        // 最近使用したファイルを読み込み
        LoadRecentFiles();
    }
    catch (Exception)
    {
        // エラーハンドリング
    }
    finally
    {
        IsLoading = false;
        _isNavigating = false;
    }
}

private void LoadDrives()
{
    Drives.Clear();
    try
    {
        var drives = _fileSystemService.GetDrives();
        foreach (var drive in drives)
        {
            try
            {
                var driveInfo = new DriveInfo(drive);
                if (driveInfo.IsReady) // ネットワークドライブで時間がかかる
                {
                    Drives.Add(new DriveInfoModel
                    {
                        Name = driveName,
                        Path = driveInfo.RootDirectory.FullName,
                        // ...
                    });
                }
            }
            catch
            {
                continue;
            }
        }
    }
    catch (Exception)
    {
        // エラーハンドリング
    }
}
```

**変更後**:
```csharp
public void NavigateToHome()
{
    // ...
    // ピン留めフォルダーを読み込み（同期的、軽量）
    LoadPinnedFolders();
    
    // 最近使用したファイルを読み込み（同期的、軽量）
    LoadRecentFiles();
    
    // ドライブ情報を非同期で読み込み（UIスレッドをブロックしない）
    _ = Task.Run(async () =>
    {
        try
        {
            await LoadDrivesAsync();
        }
        catch (Exception)
        {
            // エラーハンドリング
        }
        finally
        {
            var dispatcher = System.Windows.Application.Current?.Dispatcher;
            dispatcher?.Invoke(() =>
            {
                IsLoading = false;
                _isNavigating = false;
            });
        }
    });
}

private async Task LoadDrivesAsync()
{
    var dispatcher = System.Windows.Application.Current?.Dispatcher;
    if (dispatcher == null)
        return;
    
    // UIスレッドでクリア
    await dispatcher.InvokeAsync(() => Drives.Clear());
    
    try
    {
        var drives = _fileSystemService.GetDrives();
        var driveModels = new List<DriveInfoModel>();
        
        // バックグラウンドスレッドでドライブ情報を取得
        foreach (var drive in drives)
        {
            try
            {
                // ドライブ情報を非同期で取得（ネットワークドライブの応答待ちでUIスレッドをブロックしない）
                var driveModel = await Task.Run(() =>
                {
                    try
                    {
                        var driveInfo = new DriveInfo(drive);
                        // IsReadyプロパティの取得は同期的だが、ネットワークドライブの場合は時間がかかる可能性がある
                        // そのため、Task.Run内で実行してUIスレッドをブロックしない
                        if (driveInfo.IsReady)
                        {
                            var driveName = string.IsNullOrEmpty(driveInfo.VolumeLabel)
                                ? $"ローカルディスク ({drive.TrimEnd('\\')})"
                                : $"{driveInfo.VolumeLabel} ({drive.TrimEnd('\\')})";
                            
                            return new DriveInfoModel
                            {
                                Name = driveName,
                                Path = driveInfo.RootDirectory.FullName,
                                VolumeLabel = driveInfo.VolumeLabel,
                                TotalSize = driveInfo.TotalSize,
                                FreeSpace = driveInfo.AvailableFreeSpace
                            };
                        }
                        return null;
                    }
                    catch
                    {
                        return null;
                    }
                });
                
                if (driveModel != null)
                {
                    driveModels.Add(driveModel);
                }
            }
            catch
            {
                continue;
            }
        }
        
        // UIスレッドで一括追加
        await dispatcher.InvokeAsync(() =>
        {
            foreach (var model in driveModels)
            {
                Drives.Add(model);
            }
        });
    }
    catch (Exception)
    {
        // エラーハンドリング
    }
}
```

**効果**:
- ネットワークドライブがある場合でもUIがブロックされない

### Dispatcher.BeginInvokeの最適化
**日付**: 2025-11-21

**問題点**:
- `DispatcherPriority.Loaded`を使用していたため、レイアウト完了まで待つ必要があった

**改善内容**:
- `DispatcherPriority.Normal`に変更して高速化
- 2つの`Dispatcher.BeginInvoke`を1つに統合し、オーバーヘッドを削減

**効果**:
- ナビゲーションアイテムのクリック処理が高速化

---

## 起動時のパフォーマンス改善

### FavoriteServiceの遅延初期化
**日付**: 2025-11-20

**問題点**:
- コンストラクタでのファイルI/Oとドライブ列挙が起動を遅くしていた

**改善内容**:
- コンストラクタでのファイルI/Oとドライブ列挙を削除
- `EnsureInitialized()`で初回アクセス時に初期化
- ドライブ列挙を非同期化（バックグラウンドで実行）

**コード変更例**:

**変更前**:
```csharp
public FavoriteService()
{
    var appDataPath = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
        "FastExplorer");
    Directory.CreateDirectory(appDataPath);
    _favoritesFilePath = Path.Combine(appDataPath, "favorites.json");
    LoadFavorites(); // 起動時に同期的に読み込み
    
    // ドライブを追加（同期的に実行）
    var drives = Directory.GetLogicalDrives();
    foreach (var drive in drives)
    {
        var driveInfo = new DriveInfo(drive);
        if (driveInfo.IsReady)
        {
            AddDefaultFolder(driveName, drive);
        }
    }
}
```

**変更後**:
```csharp
private bool _isInitialized = false;
private readonly object _lockObject = new object();

public FavoriteService()
{
    var appDataPath = Path.Combine(
        Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
        "FastExplorer");
    Directory.CreateDirectory(appDataPath);
    _favoritesFilePath = Path.Combine(appDataPath, "favorites.json");
    // 起動時のパフォーマンス改善のため、初期化を遅延実行
    // LoadFavorites(); // 削除
}

/// <summary>
/// お気に入りを初期化します（遅延初期化）
/// </summary>
private void EnsureInitialized()
{
    if (_isInitialized)
        return;
    
    lock (_lockObject)
    {
        if (_isInitialized)
            return;
        
        LoadFavorites();
        _isInitialized = true;
    }
}

public IEnumerable<FavoriteItem> GetFavorites()
{
    EnsureInitialized(); // 初回アクセス時に初期化
    return _favorites.ToList();
}

// ドライブ列挙を非同期化
private void InitializeDefaultFavorites()
{
    // ...
    // ドライブを追加（非同期で実行するため、起動時は最小限の処理のみ）
    Task.Run(() =>
    {
        try
        {
            var drives = Directory.GetLogicalDrives();
            var driveFavorites = new List<FavoriteItem>();
            
            foreach (var drive in drives)
            {
                var driveInfo = new DriveInfo(drive);
                if (driveInfo.IsReady)
                {
                    driveFavorites.Add(new FavoriteItem
                    {
                        Name = driveName,
                        Path = drive
                    });
                }
            }
            
            // UIスレッドでお気に入りを更新
            Application.Current?.Dispatcher.BeginInvoke(new Action(() =>
            {
                lock (_lockObject)
                {
                    // 既存のドライブを削除
                    _favorites.RemoveAll(f => !f.Path.StartsWith("shell:") && 
                        Directory.GetLogicalDrives().Contains(f.Path, StringComparer.OrdinalIgnoreCase));
                    
                    // 新しいドライブを追加
                    foreach (var driveFavorite in driveFavorites)
                    {
                        if (!_favorites.Any(f => f.Path.Equals(driveFavorite.Path, StringComparison.OrdinalIgnoreCase)))
                        {
                            _favorites.Add(driveFavorite);
                        }
                    }
                    
                    SaveFavorites();
                }
            }), System.Windows.Threading.DispatcherPriority.Background);
        }
        catch
        {
            // エラーハンドリング
        }
    });
}
```

**効果**:
- 起動時の処理が軽量化され、ウィンドウ表示が速くなる

### MainWindowViewModelのお気に入り読み込みの遅延実行
**日付**: 2025-11-20

**問題点**:
- コンストラクタでの同期的な`LoadFavorites()`呼び出しが起動を遅くしていた

**改善内容**:
- コンストラクタでの同期的な`LoadFavorites()`呼び出しを削除
- ウィンドウ表示後に非同期で読み込むように変更（100ms遅延）

**コード変更例**:

**変更前**:
```csharp
public MainWindowViewModel(FavoriteService? favoriteService)
{
    _favoriteService = favoriteService;
    LoadFavorites(); // 起動時に同期的に読み込み（起動が遅くなる）
}
```

**変更後**:
```csharp
public MainWindowViewModel(FavoriteService? favoriteService)
{
    _favoriteService = favoriteService;
    // 起動時のパフォーマンス改善のため、お気に入りの読み込みを遅延実行
    // LoadFavorites(); // 削除
    _ = Task.Run(async () =>
    {
        // ウィンドウが表示された後に読み込む（起動を最速化）
        await Task.Delay(100);
        Application.Current?.Dispatcher.BeginInvoke(new System.Action(() =>
        {
            LoadFavorites();
        }), System.Windows.Threading.DispatcherPriority.Background);
    });
}
```

**効果**:
- 起動直後の応答性が向上

### ページの遅延読み込み
**日付**: 2025-11-20

**問題点**:
- すべてのページを起動時にインスタンス化していた

**改善内容**:
- `DashboardPage`、`DataPage`、`SettingsPage`を`Transient`に変更
- 必要になるまでインスタンス化しないように変更
- `ExplorerPage`と`ExplorerPageViewModel`は起動時に必要なので`Singleton`のまま

**コード変更例**:

**変更前** (App.xaml.cs):
```csharp
services.AddSingleton<DashboardPage>();
services.AddSingleton<DashboardViewModel>();
services.AddSingleton<DataPage>();
services.AddSingleton<DataViewModel>();
services.AddSingleton<Views.Pages.ExplorerPage>();
services.AddSingleton<ViewModels.Pages.ExplorerPageViewModel>();
services.AddSingleton<SettingsPage>();
services.AddSingleton<SettingsViewModel>();
```

**変更後** (App.xaml.cs):
```csharp
// 起動時のパフォーマンス改善のため、ページを遅延読み込み（必要になるまでインスタンス化しない）
// ExplorerPageとExplorerPageViewModelは起動時に必要なので、Singletonとして登録
services.AddSingleton<Views.Pages.ExplorerPage>();
services.AddSingleton<ViewModels.Pages.ExplorerPageViewModel>();

// その他のページは遅延読み込み（TransientまたはFactoryで生成）
services.AddTransient<DashboardPage>();
services.AddTransient<DashboardViewModel>();
services.AddTransient<DataPage>();
services.AddTransient<DataViewModel>();
services.AddTransient<SettingsPage>();
services.AddTransient<SettingsViewModel>();
```

**効果**:
- 起動時のメモリ使用量を削減

### テーマ適用の最適化
**日付**: 2025-11-20

**問題点**:
- ウィンドウ表示前にテーマが適用されず、ちらつきが発生していた

**改善内容**:
- `OnStartup`でテーマ適用後に`Dispatcher.Invoke()`で処理を同期
- `MainWindow`のコンストラクタで`InitializeComponent()`の前にテーマ適用を確認

**効果**:
- ウィンドウ表示前にテーマが適用され、ちらつきを防止

---

## メモリとキャッシュの最適化

### MainWindowViewModel.LoadFavorites()の最適化
**日付**: 2025-11-20

**問題点**:
- お気に入り追加・削除のたびに`MenuItems`を全クリアして再作成していた

**改善内容**:
- 差分更新に変更。追加・削除・変更のみを反映
- ホームアイテムをキャッシュして再利用

**コード変更例**:

**変更前**:
```csharp
public void LoadFavorites()
{
    MenuItems.Clear();
    
    // エクスプローラーページへのリンクを追加
    var explorerItem = new NavigationViewItem()
    {
        Content = "ホーム",
        Icon = new SymbolIcon { Symbol = SymbolRegular.Folder24 },
        Tag = "HOME"
    };
    MenuItems.Add(explorerItem);
    
    // お気に入りを追加
    var favorites = _favoriteService.GetFavorites();
    foreach (var favorite in favorites)
    {
        MenuItems.Add(CreateFavoriteNavigationItem(favorite));
    }
}
```

**変更後**:
```csharp
private NavigationViewItem? _homeMenuItem;

public void LoadFavorites()
{
    // ホームアイテムが存在しない場合は作成
    if (_homeMenuItem == null)
    {
        _homeMenuItem = new NavigationViewItem()
        {
            Content = "ホーム",
            Icon = new SymbolIcon { Symbol = SymbolRegular.Folder24 },
            Tag = "HOME"
        };
        _homeMenuItem.Click += (s, e) => { NavigateToHome(); };
    }
    
    // 現在のお気に入りを取得
    var currentFavorites = _favoriteService.GetFavorites().ToList();
    
    // 既存のメニューアイテムからお気に入りアイテムを抽出（ホームアイテムを除く）
    var existingFavoriteItems = MenuItems
        .OfType<NavigationViewItem>()
        .Where(item => item.Tag is string tag && tag != "HOME")
        .ToList();
    
    // 既存のお気に入りパスを取得
    var existingPaths = existingFavoriteItems
        .Select(item => item.Tag as string)
        .Where(path => !string.IsNullOrEmpty(path))
        .ToHashSet(StringComparer.OrdinalIgnoreCase);
    
    // 新しいお気に入りのパスを取得
    var newPaths = currentFavorites
        .Select(f => f.Path)
        .ToHashSet(StringComparer.OrdinalIgnoreCase);
    
    // 削除されたお気に入りをメニューから削除
    var itemsToRemove = existingFavoriteItems
        .Where(item => item.Tag is string tag && !newPaths.Contains(tag))
        .ToList();
    foreach (var item in itemsToRemove)
    {
        MenuItems.Remove(item);
    }
    
    // 新しく追加されたお気に入りをメニューに追加
    var itemsToAdd = currentFavorites
        .Where(f => !existingPaths.Contains(f.Path))
        .Select(CreateFavoriteNavigationItem)
        .ToList();
    
    // ホームアイテムが存在しない場合は先頭に追加
    if (!MenuItems.Contains(_homeMenuItem))
    {
        MenuItems.Insert(0, _homeMenuItem);
    }
    
    // 新しいお気に入りアイテムを追加（ホームアイテムの後）
    var homeIndex = MenuItems.IndexOf(_homeMenuItem);
    for (int i = 0; i < itemsToAdd.Count; i++)
    {
        MenuItems.Insert(homeIndex + 1 + i, itemsToAdd[i]);
    }
    
    // 既存アイテムの名前が変更された場合は更新
    foreach (var favorite in currentFavorites)
    {
        var existingItem = existingFavoriteItems
            .FirstOrDefault(item => item.Tag is string tag && 
                                  string.Equals(tag, favorite.Path, StringComparison.OrdinalIgnoreCase));
        if (existingItem != null && existingItem.Content?.ToString() != favorite.Name)
        {
            existingItem.Content = favorite.Name;
        }
    }
}
```

**効果**:
- お気に入りの追加・削除が高速化

### GetService()のキャッシュ
**日付**: 2025-11-20

**問題点**:
- `NavigateToHome()`と`NavigateToFavorite()`で毎回`App.Services.GetService()`を呼び出していた
- `UpdateStatusBar()`で毎回`App.Services.GetService()`を呼び出していた

**改善内容**:
- `ExplorerPageViewModel`をキャッシュして再利用
- `MainWindowViewModel`をキャッシュして再利用

**コード変更例**:

**MainWindowViewModel.cs - 変更前**:
```csharp
public void NavigateToHome()
{
    Application.Current.Dispatcher.BeginInvoke(new System.Action(() =>
    {
        var explorerPageViewModel = App.Services.GetService(ExplorerPageViewModelType) 
            as ViewModels.Pages.ExplorerPageViewModel;
        if (explorerPageViewModel != null && explorerPageViewModel.SelectedTab != null)
        {
            explorerPageViewModel.SelectedTab.ViewModel.NavigateToHome();
        }
    }), System.Windows.Threading.DispatcherPriority.Loaded);
}
```

**MainWindowViewModel.cs - 変更後**:
```csharp
private ViewModels.Pages.ExplorerPageViewModel? _cachedExplorerPageViewModel;

public void NavigateToHome()
{
    Application.Current.Dispatcher.BeginInvoke(new System.Action(() =>
    {
        // ViewModelをキャッシュから取得（なければ取得してキャッシュ）
        if (_cachedExplorerPageViewModel == null)
        {
            _cachedExplorerPageViewModel = App.Services.GetService(ExplorerPageViewModelType) 
                as ViewModels.Pages.ExplorerPageViewModel;
        }
        
        if (_cachedExplorerPageViewModel != null && 
            _cachedExplorerPageViewModel.SelectedTab != null)
        {
            _cachedExplorerPageViewModel.SelectedTab.ViewModel.NavigateToHome();
        }
    }), System.Windows.Threading.DispatcherPriority.Loaded);
}
```

**ExplorerPageViewModel.cs - 変更前**:
```csharp
private void UpdateStatusBar()
{
    var mainWindowViewModel = App.Services.GetService(typeof(ViewModels.Windows.MainWindowViewModel)) 
        as ViewModels.Windows.MainWindowViewModel;
    if (mainWindowViewModel == null)
        return;
    
    // ...
    mainWindowViewModel.StatusBarText = $"パス: {path} {itemCount}個の項目";
}
```

**ExplorerPageViewModel.cs - 変更後**:
```csharp
private ViewModels.Windows.MainWindowViewModel? _cachedMainWindowViewModel;

private void UpdateStatusBar()
{
    // MainWindowViewModelをキャッシュから取得（なければ取得してキャッシュ）
    if (_cachedMainWindowViewModel == null)
    {
        _cachedMainWindowViewModel = App.Services.GetService(typeof(ViewModels.Windows.MainWindowViewModel)) 
            as ViewModels.Windows.MainWindowViewModel;
    }
    
    if (_cachedMainWindowViewModel == null)
        return;
    
    // ...
    _cachedMainWindowViewModel.StatusBarText = $"パス: {path} {itemCount}個の項目";
}
```

**効果**:
- サービス取得のオーバーヘッド削減

### OnClosingメソッドの最適化
**日付**: 2025-11-21

**問題点**:
- `List<string>`の容量を事前に確保していなかった

**改善内容**:
- `List<string>`の容量を事前に確保してメモリ再割り当てを削減

**コード変更例**:

**変更前**:
```csharp
var leftPaneTabPaths = new System.Collections.Generic.List<string>();
foreach (var tab in _cachedExplorerPageViewModel.LeftPaneTabs)
{
    leftPaneTabPaths.Add(tab.CurrentPath ?? string.Empty);
}

var rightPaneTabPaths = new System.Collections.Generic.List<string>();
foreach (var tab in _cachedExplorerPageViewModel.RightPaneTabs)
{
    rightPaneTabPaths.Add(tab.CurrentPath ?? string.Empty);
}

var tabPaths = new System.Collections.Generic.List<string>();
foreach (var tab in _cachedExplorerPageViewModel.Tabs)
{
    tabPaths.Add(tab.CurrentPath ?? string.Empty);
}
```

**変更後**:
```csharp
var leftPaneTabs = _cachedExplorerPageViewModel.LeftPaneTabs;
var leftPaneTabPaths = new System.Collections.Generic.List<string>(leftPaneTabs.Count);
foreach (var tab in leftPaneTabs)
{
    leftPaneTabPaths.Add(tab.CurrentPath ?? string.Empty);
}

var rightPaneTabs = _cachedExplorerPageViewModel.RightPaneTabs;
var rightPaneTabPaths = new System.Collections.Generic.List<string>(rightPaneTabs.Count);
foreach (var tab in rightPaneTabs)
{
    rightPaneTabPaths.Add(tab.CurrentPath ?? string.Empty);
}

var tabs = _cachedExplorerPageViewModel.Tabs;
var tabPaths = new System.Collections.Generic.List<string>(tabs.Count);
foreach (var tab in tabs)
{
    tabPaths.Add(tab.CurrentPath ?? string.Empty);
}
```

**効果**:
- タブ数が多い場合のメモリ割り当てとGC負荷を削減

### プロパティアクセスの最適化
**日付**: 2025-11-22

**問題点**:
- `InvalidateProperty`呼び出しで静的プロパティに毎回アクセスしていた

**改善内容**:
- プロパティをローカル変数にキャッシュして再利用

**コード変更例**:

**変更前**:
```csharp
private static void InvalidateTabItems(TabControl tabControl)
{
    var childrenCount = VisualTreeHelper.GetChildrenCount(tabControl);
    for (int i = 0; i < childrenCount; i++)
    {
        var child = VisualTreeHelper.GetChild(tabControl, i);
        if (child is TabItem tabItem)
        {
            tabItem.InvalidateProperty(FrameworkElement.StyleProperty);
            tabItem.InvalidateProperty(TabItem.BackgroundProperty);
        }
        // ...
        if (tabItemChild is TabItem tabItem2)
        {
            tabItem2.InvalidateProperty(FrameworkElement.StyleProperty);
            tabItem2.InvalidateProperty(TabItem.BackgroundProperty);
        }
    }
}
```

**変更後**:
```csharp
private static void InvalidateTabItems(TabControl tabControl)
{
    // プロパティをキャッシュして高速化（静的フィールドアクセスを削減）
    var styleProperty = FrameworkElement.StyleProperty;
    var backgroundProperty = TabItem.BackgroundProperty;
    
    var childrenCount = VisualTreeHelper.GetChildrenCount(tabControl);
    for (int i = 0; i < childrenCount; i++)
    {
        var child = VisualTreeHelper.GetChild(tabControl, i);
        if (child is TabItem tabItem)
        {
            tabItem.InvalidateProperty(styleProperty);
            tabItem.InvalidateProperty(backgroundProperty);
        }
        // ...
        if (tabItemChild is TabItem tabItem2)
        {
            tabItem2.InvalidateProperty(styleProperty);
            tabItem2.InvalidateProperty(backgroundProperty);
        }
    }
}
```

**効果**:
- 静的フィールドアクセスを削減

---

## ビジュアルツリー走査の最適化

### InvalidateTabAndListViewStylesメソッドの最適化
**日付**: 2025-11-21

**問題点**:
- 複数回の`FindVisualChild`呼び出しでビジュアルツリーを走査していた

**改善内容**:
- `TabControl`と`ListView`を一度の走査で取得
- `FindVisualChild`の再帰呼び出しを直接走査に置き換え
- 早期終了チェックをループの最初に移動

**コード変更例**:

**変更前**:
```csharp
private void InvalidateTabAndListViewStyles(Window window)
{
    var explorerPage = FindVisualChild<Views.Pages.ExplorerPage>(window);
    if (explorerPage != null)
    {
        // TabControl内のすべてのTabItemのスタイルを無効化
        var tabControl = FindVisualChild<System.Windows.Controls.TabControl>(explorerPage);
        if (tabControl != null)
        {
            tabControl.InvalidateProperty(System.Windows.Controls.Control.TemplateProperty);
            
            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(tabControl); i++)
            {
                var child = VisualTreeHelper.GetChild(tabControl, i);
                if (child is TabItem tabItem)
                {
                    tabItem.InvalidateProperty(FrameworkElement.StyleProperty);
                    tabItem.InvalidateProperty(TabItem.BackgroundProperty);
                }
                var tabPanel = FindVisualChild<TabPanel>(child);
                if (tabPanel != null)
                {
                    // さらに走査...
                }
            }
        }
        
        // ListView内のすべてのListViewItemのスタイルを無効化
        var listView = FindVisualChild<ListView>(explorerPage);
        if (listView != null)
        {
            listView.InvalidateProperty(ItemsControl.ItemContainerStyleProperty);
            // ...
        }
    }
}
```

**変更後**:
```csharp
private void InvalidateTabAndListViewStyles(Window window)
{
    var explorerPage = FindVisualChild<Views.Pages.ExplorerPage>(window);
    if (explorerPage == null)
        return;
    
    // TabControlとListViewを一度の走査で見つける（高速化）
    TabControl? tabControl = null;
    ListView? listView = null;
    
    FindTabControlAndListView(explorerPage, ref tabControl, ref listView);
    
    // TabControl内のすべてのTabItemのスタイルを無効化
    if (tabControl != null)
    {
        tabControl.InvalidateProperty(Control.TemplateProperty);
        InvalidateTabItems(tabControl);
    }
    
    // ListView内のすべてのListViewItemのスタイルを無効化
    if (listView != null)
    {
        listView.InvalidateProperty(ItemsControl.ItemContainerStyleProperty);
        InvalidateListViewItems(listView);
    }
}

private static void FindTabControlAndListView(
    DependencyObject parent,
    ref TabControl? tabControl,
    ref ListView? listView)
{
    if (parent == null)
        return;
    
    // 両方見つかった場合は早期終了
    if (tabControl != null && listView != null)
        return;
    
    var childrenCount = VisualTreeHelper.GetChildrenCount(parent);
    for (int i = 0; i < childrenCount; i++)
    {
        // 両方見つかった場合は早期終了
        if (tabControl != null && listView != null)
            return;
        
        var child = VisualTreeHelper.GetChild(parent, i);
        
        // 型チェックを最適化
        if (tabControl == null && child is TabControl tc)
        {
            tabControl = tc;
        }
        else if (listView == null && child is ListView lv)
        {
            listView = lv;
        }
        
        // 再帰的に検索
        FindTabControlAndListView(child, ref tabControl, ref listView);
        
        if (tabControl != null && listView != null)
            return;
    }
}

private static void InvalidateTabItems(TabControl tabControl)
{
    // プロパティをキャッシュして高速化
    var styleProperty = FrameworkElement.StyleProperty;
    var backgroundProperty = TabItem.BackgroundProperty;
    
    var childrenCount = VisualTreeHelper.GetChildrenCount(tabControl);
    for (int i = 0; i < childrenCount; i++)
    {
        var child = VisualTreeHelper.GetChild(tabControl, i);
        if (child is TabItem tabItem)
        {
            tabItem.InvalidateProperty(styleProperty);
            tabItem.InvalidateProperty(backgroundProperty);
        }
        
        // FindVisualChildの代わりに直接走査（高速化）
        var childChildrenCount = VisualTreeHelper.GetChildrenCount(child);
        for (int j = 0; j < childChildrenCount; j++)
        {
            var grandChild = VisualTreeHelper.GetChild(child, j);
            if (grandChild is TabPanel tabPanel)
            {
                var panelChildrenCount = VisualTreeHelper.GetChildrenCount(tabPanel);
                for (int k = 0; k < panelChildrenCount; k++)
                {
                    var tabItemChild = VisualTreeHelper.GetChild(tabPanel, k);
                    if (tabItemChild is TabItem tabItem2)
                    {
                        tabItem2.InvalidateProperty(styleProperty);
                        tabItem2.InvalidateProperty(backgroundProperty);
                    }
                }
            }
        }
    }
}
```

**効果**:
- ビジュアルツリー走査の回数を削減
- テーマカラー変更時のスタイル更新処理が高速化

---

## その他の最適化

### MainWindow_KeyDownメソッドの最適化
**日付**: 2025-11-21

**問題点**:
- 型チェックが非効率だった

**改善内容**:
- 早期リターンで不要な処理をスキップ
- 型チェックをパターンマッチング（`or`演算子）で統合

**効果**:
- キーボード入力処理が高速化

### RootNavigation_ItemInvokedメソッドの最適化
**日付**: 2025-11-21, 2025-11-22

**問題点**:
- 2つの`Dispatcher.BeginInvoke`を呼び出していた
- 不要な変数のキャプチャが発生していた

**改善内容**:
- `Dispatcher.BeginInvoke`の条件分岐を外に出すことで、不要な変数のキャプチャを削減
- 文字列比較に`ReadOnlySpan<char>`を使用してメモリ割り当てを削減

**コード変更例**:

**変更前**:
```csharp
private void RootNavigation_ItemInvoked(object sender, object args)
{
    // ...
    var isHome = string.Equals(tag, HomeTag, StringComparison.Ordinal);
    
    if (isHome)
    {
        _ = Dispatcher.BeginInvoke(new System.Action(() =>
        {
            viewModel.NavigateToHome();
        }), DispatcherPriority.Loaded);
    }
    else
    {
        var path = tag;
        _ = Dispatcher.BeginInvoke(new System.Action(() =>
        {
            viewModel.NavigateToPathCommand.Execute(path);
        }), DispatcherPriority.Loaded);
    }
}
```

**変更後**:
```csharp
private void RootNavigation_ItemInvoked(object sender, object args)
{
    // ...
    // ReadOnlySpan<char>を使用してメモリ割り当てを削減（高速化）
    var isHome = tag.AsSpan().SequenceEqual(HomeTag.AsSpan());
    
    // 条件分岐を簡略化してキャプチャする変数を削減（高速化）
    if (isHome)
    {
        _ = Dispatcher.BeginInvoke(new System.Action(() =>
        {
            viewModel.NavigateToHome(addToHistory: true);
        }), DispatcherPriority.Normal);
    }
    else
    {
        var path = tag; // クロージャで使用するため変数に保存
        _ = Dispatcher.BeginInvoke(new System.Action(() =>
        {
            viewModel.NavigateToPathCommand.Execute(path);
        }), DispatcherPriority.Normal);
    }
}
```

**効果**:
- クロージャのメモリ割り当てを削減
- ナビゲーションアイテムのクリック処理が高速化
- `DispatcherPriority.Loaded`から`Normal`に変更してレイアウト完了を待たずに実行

### FindTabControlAndListViewメソッドの最適化
**日付**: 2025-11-22

**問題点**:
- 型チェックが非効率だった

**改善内容**:
- 早期終了チェックをループの最初に移動
- 型チェックをif-elseに変更（switch式よりわずかに高速）

**効果**:
- 不要な再帰呼び出しを削減
- 型チェックが高速化

### 文字列比較の最適化
**日付**: 2025-11-22

**問題点**:
- 文字列長チェックが非効率だった

**改善内容**:
- `Length > 0`を`Length != 0`に変更（等価比較がわずかに高速）

**効果**:
- 文字列長チェックの微細な高速化

### テーマ保存処理の最適化
**日付**: 2025-11-22

**問題点**:
- if-else文でテーマを保存していた

**改善内容**:
- switch式を使用してテーマを保存

**効果**:
- テーマ保存処理がわずかに高速化

---

## 改善の効果まとめ

### 起動時の改善
- 起動時の処理が軽量化され、ウィンドウ表示が速くなる
- お気に入りの読み込みやドライブ列挙はバックグラウンドで実行されるため、起動直後の応答性が向上

### 動作時の改善
- ファイルシステム操作の効率化により、特に大量のファイルがあるディレクトリでの表示速度が向上
- UIスレッドのブロックを防止し、大量ファイルでもUIがフリーズしない
- ネットワークドライブがある場合でもUIがブロックされない

### メモリ使用量の改善
- お気に入りの追加・削除が高速化
- サービス取得のオーバーヘッド削減
- タブ数が多い場合のメモリ割り当てとGC負荷を削減

### UI応答性の改善
- テーマカラー変更時のスタイル更新処理が高速化
- キーボード入力処理が高速化
- ナビゲーションアイテムのクリック処理が高速化
- 背景色更新処理が高速化（WindowSettingsServiceとFindResource()のキャッシュ）
- ビジュアルツリー走査が高速化（GetChildrenCount()の結果をキャッシュ）
- タブ操作が高速化（プロパティアクセスの削減）

### 2025-11-24の追加改善
- **キャッシングの強化**: WindowSettingsService、FindResource()の結果、ViewModelプロパティをキャッシュ
- **ビジュアルツリー走査の最適化**: 深度制限とGetChildrenCount()の結果をキャッシュ
- **プロパティアクセスの削減**: Countプロパティやコレクション参照をローカル変数にキャッシュ
- **文字列操作の最適化**: TrimEnd()の代わりに末尾のみをチェック、ToString()の呼び出しを回避
- **型チェックの最適化**: パターンマッチングを使用
- **ループの最適化**: 早期break、条件分岐の最適化
- **ファイルシステムアクセスの削減**: IsDirectoryで分岐して必要なチェックのみ実行
- **不要なチェックの削減**: 重複するstring.IsNullOrEmpty()チェックを削除

---

## さらなる最適化（2025-11-24）

### ExplorerPage.xaml.cs - UpdateListViewBackgroundColors()の最適化
**日付**: 2025-11-24

**問題点**:
- `App.Services.GetService()`を毎回2回呼び出していた
- `FindResource()`を複数回呼び出していた
- `ViewModel`プロパティに複数回アクセスしていた

**改善内容**:
- `WindowSettingsService`をキャッシュして再利用
- `FindResource()`の結果（`UnfocusedPaneBackgroundBrush`、`ControlFillColorDefaultBrush`）をキャッシュ
- `ViewModel`プロパティをローカル変数にキャッシュ
- 背景色を事前に決定して条件分岐を削減
- ヘルパーメソッド（`CreateDefaultUnfocusedBrush()`、`CreateDefaultFocusedBrush()`）を追加

**コード変更例**:

**変更前**:
```csharp
private void UpdateListViewBackgroundColors()
{
    // 毎回GetService()を呼び出し
    var windowSettingsService = App.Services.GetService(typeof(Services.WindowSettingsService)) as Services.WindowSettingsService;
    if (windowSettingsService != null)
    {
        var settings = windowSettingsService.GetSettings();
        // ...
    }
    // 再度GetService()を呼び出し
    var windowSettingsService2 = App.Services.GetService(typeof(Services.WindowSettingsService)) as Services.WindowSettingsService;
    // ...
}
```

**変更後**:
```csharp
// キャッシュフィールドを追加
private Services.WindowSettingsService? _cachedWindowSettingsService;
private Brush? _cachedUnfocusedPaneBackgroundBrush;
private Brush? _cachedControlFillColorDefaultBrush;

private void UpdateListViewBackgroundColors()
{
    // WindowSettingsServiceをキャッシュ（パフォーマンス向上）
    if (_cachedWindowSettingsService == null)
    {
        _cachedWindowSettingsService = App.Services.GetService(typeof(Services.WindowSettingsService)) as Services.WindowSettingsService;
    }
    
    // ViewModelプロパティをキャッシュ
    var viewModel = ViewModel;
    var isSplitPaneEnabled = viewModel.IsSplitPaneEnabled;
    
    // FindResource()の結果をキャッシュ
    if (_cachedUnfocusedPaneBackgroundBrush == null)
    {
        _cachedUnfocusedPaneBackgroundBrush = FindResource("UnfocusedPaneBackgroundBrush") as Brush;
    }
    // ...
}
```

**効果**:
- UI応答性の向上（背景色更新が高速化）
- メモリ使用量の削減（不要なオブジェクト生成を削減）

### ExplorerPage.xaml.cs - FindChild()とGetScrollViewer()の最適化
**日付**: 2025-11-24

**問題点**:
- `VisualTreeHelper.GetChildrenCount()`をループ内で毎回呼び出していた

**改善内容**:
- `GetChildrenCount()`の結果を一度だけ取得してキャッシュ

**コード変更例**:

**変更前**:
```csharp
private T? FindChild<T>(DependencyObject parent, Func<T, bool>? predicate) where T : DependencyObject
{
    for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
    {
        // ...
    }
}
```

**変更後**:
```csharp
private T? FindChild<T>(DependencyObject parent, Func<T, bool>? predicate) where T : DependencyObject
{
    // 子要素の数を一度だけ取得してキャッシュ（パフォーマンス向上）
    var childrenCount = VisualTreeHelper.GetChildrenCount(parent);
    for (int i = 0; i < childrenCount; i++)
    {
        // ...
    }
}
```

**効果**:
- ビジュアルツリー走査の高速化

### ExplorerPage.xaml.cs - CopyPathButton_Click()の最適化
**日付**: 2025-11-24

**問題点**:
- ビジュアルツリー走査に深度制限がなかった
- `ViewModel`プロパティに複数回アクセスしていた

**改善内容**:
- ビジュアルツリー走査の最大深度を5階層に制限
- `ViewModel`プロパティをローカル変数にキャッシュ

**コード変更例**:

**変更前**:
```csharp
private void CopyPathButton_Click(object sender, RoutedEventArgs e)
{
    var current = VisualTreeHelper.GetParent(buttonElement);
    while (current != null) // 深度制限なし
    {
        // ...
        current = VisualTreeHelper.GetParent(current);
    }
    
    tab ??= ViewModel.IsSplitPaneEnabled
        ? (ViewModel.ActivePane == 0 ? ViewModel.SelectedLeftPaneTab
           : ViewModel.ActivePane == 2 ? ViewModel.SelectedRightPaneTab
           : ViewModel.SelectedLeftPaneTab ?? ViewModel.SelectedRightPaneTab)
        : ViewModel.SelectedTab;
}
```

**変更後**:
```csharp
private void CopyPathButton_Click(object sender, RoutedEventArgs e)
{
    var current = VisualTreeHelper.GetParent(buttonElement);
    int depth = 0;
    const int maxDepth = 5; // 最大深度を制限してパフォーマンス向上
    while (current != null && depth < maxDepth)
    {
        // ...
        current = VisualTreeHelper.GetParent(current);
        depth++;
    }
    
    // ViewModelプロパティをキャッシュ
    var viewModel = ViewModel;
    if (tab == null)
    {
        if (viewModel.IsSplitPaneEnabled)
        {
            var activePane = viewModel.ActivePane;
            tab = activePane == 0 ? viewModel.SelectedLeftPaneTab
                : activePane == 2 ? viewModel.SelectedRightPaneTab
                : viewModel.SelectedLeftPaneTab ?? viewModel.SelectedRightPaneTab;
        }
        else
        {
            tab = viewModel.SelectedTab;
        }
    }
}
```

**効果**:
- ビジュアルツリー走査の高速化（深度制限により不要な走査を削減）

### ExplorerPageViewModel.cs - CloseTab()の最適化
**日付**: 2025-11-24

**問題点**:
- `Count`プロパティに複数回アクセスしていた
- コレクション参照をキャッシュしていなかった

**改善内容**:
- `Count`プロパティを一度だけ取得してキャッシュ
- コレクション参照をローカル変数にキャッシュ

**コード変更例**:

**変更前**:
```csharp
var leftIndex = LeftPaneTabs.IndexOf(tab);
if (leftIndex >= 0)
{
    if (LeftPaneTabs.Count <= 1) // Countプロパティにアクセス
        return;
    LeftPaneTabs.RemoveAt(leftIndex);
    if (SelectedLeftPaneTab == tab)
    {
        if (leftIndex > 0)
            SelectedLeftPaneTab = LeftPaneTabs[leftIndex - 1];
        else if (LeftPaneTabs.Count > 0) // 再度Countプロパティにアクセス
            SelectedLeftPaneTab = LeftPaneTabs[0];
    }
}
```

**変更後**:
```csharp
var leftPaneTabs = LeftPaneTabs; // コレクション参照をキャッシュ
var leftIndex = leftPaneTabs.IndexOf(tab);
if (leftIndex >= 0)
{
    var leftPaneTabsCount = leftPaneTabs.Count; // Countプロパティを一度だけ取得
    if (leftPaneTabsCount <= 1)
        return;
    leftPaneTabs.RemoveAt(leftIndex);
    if (SelectedLeftPaneTab == tab)
    {
        if (leftIndex > 0)
            SelectedLeftPaneTab = leftPaneTabs[leftIndex - 1];
        else if (leftPaneTabs.Count > 0)
            SelectedLeftPaneTab = leftPaneTabs[0];
    }
}
```

**効果**:
- プロパティアクセスの削減
- コレクション操作の高速化

### ExplorerPageViewModel.cs - UpdateTabTitle()の最適化
**日付**: 2025-11-24

**問題点**:
- `TrimEnd('\\')`が文字列全体を走査していた

**改善内容**:
- 末尾のバックスラッシュのみをチェックして`Substring()`を使用

**コード変更例**:

**変更前**:
```csharp
var root = Path.GetPathRoot(currentPath);
tab.Title = string.IsNullOrEmpty(root) ? currentPath : root.TrimEnd('\\');
```

**変更後**:
```csharp
var root = Path.GetPathRoot(currentPath);
if (string.IsNullOrEmpty(root))
{
    tab.Title = currentPath;
}
else
{
    // TrimEnd()を最適化（末尾のバックスラッシュのみをチェック）
    var rootLength = root.Length;
    if (rootLength > 0 && root[rootLength - 1] == '\\')
    {
        tab.Title = root.Substring(0, rootLength - 1);
    }
    else
    {
        tab.Title = root;
    }
}
```

**効果**:
- 文字列操作の高速化（`TrimEnd()`の代わりに末尾のみをチェック）

### FileSystemService.cs - GetItems()の最適化
**日付**: 2025-11-24

**問題点**:
- 型チェックが非効率だった

**改善内容**:
- パターンマッチングを使用して型チェックを高速化

**コード変更例**:

**変更前**:
```csharp
if (!isDirectory)
{
    var fileInfo = info as FileInfo;
    if (fileInfo != null)
    {
        size = fileInfo.Length;
    }
}
```

**変更後**:
```csharp
if (!isDirectory && info is FileInfo fileInfo)
{
    size = fileInfo.Length;
}
```

**効果**:
- 型チェックの高速化（パターンマッチングを使用）

### ExplorerViewModel.cs - AddToRecentFiles()の最適化
**日付**: 2025-11-24

**問題点**:
- ループ内で`RemoveAt()`を呼び出し、見つかった後も続行していた

**改善内容**:
- 一度見つかったら`break`でループを終了（通常は1件しか存在しないため）

**コード変更例**:

**変更前**:
```csharp
for (int i = _recentFiles.Count - 1; i >= 0; i--)
{
    if (/* 一致する場合 */)
    {
        _recentFiles.RemoveAt(i);
        // breakがないため、続行する
    }
}
```

**変更後**:
```csharp
var recentFilesCount = _recentFiles.Count;
for (int i = recentFilesCount - 1; i >= 0; i--)
{
    if (/* 一致する場合 */)
    {
        _recentFiles.RemoveAt(i);
        break; // 一度見つかったら終了
    }
}
```

**効果**:
- ループの早期終了により、処理が高速化

### ExplorerViewModel.cs - LoadRecentFiles()の最適化
**日付**: 2025-11-24

**問題点**:
- `File.Exists()`と`Directory.Exists()`を毎回両方呼び出していた
- リストの容量を事前に確保していなかった

**改善内容**:
- `IsDirectory`プロパティで分岐して、必要なチェックのみ実行
- 有効なファイルを一時リストに集めてから一括追加

**コード変更例**:

**変更前**:
```csharp
for (int i = 0; i < count; i++)
{
    var file = _recentFiles[i];
    if (File.Exists(file.FullPath) || Directory.Exists(file.FullPath))
    {
        recentFilesList.Add(file);
    }
}
```

**変更後**:
```csharp
var validFiles = new List<FileSystemItem>(count);
for (int i = 0; i < count; i++)
{
    var file = _recentFiles[i];
    var fullPath = file.FullPath;
    if (file.IsDirectory)
    {
        if (Directory.Exists(fullPath))
        {
            validFiles.Add(file);
        }
    }
    else
    {
        if (File.Exists(fullPath))
        {
            validFiles.Add(file);
        }
    }
}
foreach (var file in validFiles)
{
    recentFilesList.Add(file);
}
```

**効果**:
- ファイルシステムアクセスの削減（必要なチェックのみ実行）
- メモリ割り当ての削減（リストの容量を事前に確保）

### ExplorerPage.xaml.cs - TabArea_ButtonClick()の最適化
**日付**: 2025-11-24

**問題点**:
- `Tag?.ToString()`でメモリ割り当てが発生していた

**改善内容**:
- パターンマッチングを使用して文字列として直接比較

**コード変更例**:

**変更前**:
```csharp
if (sender is Button button && button.Tag?.ToString() == "CloseButton")
{
    return;
}
```

**変更後**:
```csharp
if (sender is Button button)
{
    var tag = button.Tag;
    if (tag is string tagString && tagString == "CloseButton")
    {
        return;
    }
}
```

**効果**:
- メモリ割り当ての削減（`ToString()`の呼び出しを回避）

### ExplorerPageViewModel.cs - CopyTabPath()の最適化
**日付**: 2025-11-24

**問題点**:
- `string.IsNullOrEmpty()`を2回呼び出していた

**改善内容**:
- 1回のチェックで十分なため、2回目のチェックを削除

**コード変更例**:

**変更前**:
```csharp
var path = tab.ViewModel?.CurrentPath;
if (string.IsNullOrEmpty(path))
{
    path = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
}

if (!string.IsNullOrEmpty(path)) // 2回目のチェック
{
    try
    {
        System.Windows.Clipboard.SetText(path);
    }
    catch { }
}
```

**変更後**:
```csharp
var path = tab.ViewModel?.CurrentPath;
if (string.IsNullOrEmpty(path))
{
    path = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
}

// pathは上記で必ず設定されるため、再度チェックは不要
try
{
    System.Windows.Clipboard.SetText(path);
}
catch { }
```

**効果**:
- 不要な文字列チェックの削減

---

## 参考ファイル

以下の`.specstory/history`フォルダー内のmdファイルから情報を取得しました：

1. `2025-11-16_22-09+0900-もっと高速化の提案.md`
2. `2025-11-17_00-56+0900-動作のパフォーマンス改善.md`
3. `2025-11-20_07-37+0900-パフォーマンスが悪い処理の確認.md`
4. `2025-11-20_22-48+0900-起動時のパフォーマンス改善.md`
5. `2025-11-21_02-57+0900-速度を上げるリクエスト.md`
6. `2025-11-21_20-18+0900-高速化の可能性を探る.md`
7. `2025-11-24_18-41+0900-タブの文字がボタンにならない問題.md`（最適化部分）

---

*このドキュメントは、2025年11月16日から2025年11月24日までのパフォーマンス改善に関するやり取りをまとめたものです。*

