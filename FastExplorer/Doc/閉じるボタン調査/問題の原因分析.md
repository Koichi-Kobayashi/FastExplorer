# 問題の原因分析

## 現在の状況

非クライアント領域をクリックした場合、閉じるボタンなどが押せない問題が続いています。

## 現在の実装

1. **メッセージフックで非クライアント領域のメッセージを完全にスキップ**
   - `WM_SYSCOMMAND`、`WM_NCLBUTTONDOWN`、`WM_NCHITTEST`などの非クライアント領域のメッセージをメッセージフックで処理せず、即座にスキップ
   - `WindowChrome`の処理に委譲

2. **メニュー関連のメッセージのみを処理**
   - `WM_INITMENUPOPUP`、`WM_DRAWITEM`、`WM_MEASUREITEM`、`WM_MENUCHAR`のみを処理

3. **TrackPopupMenuExが返った時点でリセット**
   - `ShowContextMenu`メソッド内で`TrackPopupMenuEx`が返った時点で`ResetMenuState()`を呼び出し

## 考えられる原因

### 1. メッセージフックの処理順序の問題
- メッセージフックが`WindowChrome`の処理の前または後に呼ばれる可能性がある
- メッセージフックが呼ばれるだけで、`WindowChrome`の処理に影響を与える可能性がある

### 2. TrackPopupMenuExのモーダルループの問題
- `TrackPopupMenuEx`はモーダルなメッセージループを開始する
- 非クライアント領域をクリックした場合、`TrackPopupMenuEx`が返る前にメッセージフックが呼ばれる可能性がある
- メッセージフックが呼ばれることで、`WindowChrome`の処理が妨げられる可能性がある

### 3. WindowChromeの処理タイミングの問題
- `WindowChrome`が非クライアント領域のメッセージを処理する際、メッセージフックが呼ばれることで処理が妨げられる可能性がある
- メッセージフックで`handled = false`にしても、メッセージフックが呼ばれることで処理順序が変わる可能性がある

## 解決策の検討

### 1. メッセージフックを完全に削除（不可）
- `IContextMenu3`のメッセージ処理が必要なため、メッセージフックは必要
- メッセージフックを削除すると、`IContextMenu3`のメッセージ処理ができなくなる

### 2. メッセージフックの処理を最小限にする（現在の実装）
- 非クライアント領域のメッセージを完全にスキップ
- メニュー関連のメッセージのみを処理
- しかし、まだ問題が解決していない

### 3. メッセージフックの処理順序を変更
- メッセージフックを`WindowChrome`の処理の後に呼び出すようにする
- しかし、WPFのメッセージフックの処理順序を制御することは難しい

### 4. TrackPopupMenuExの代わりに別の方法を使用
- `TrackPopupMenu`や`TrackPopupMenuEx`の代わりに、WPFの`ContextMenu`を使用する
- しかし、OS標準のコンテキストメニューを表示する必要があるため、この方法は使用できない

## 次のステップ

1. **メッセージフックの処理順序を確認**
   - `WindowChrome`の処理の前または後にメッセージフックが呼ばれるかを確認
   - メッセージフックが呼ばれるだけで、`WindowChrome`の処理に影響を与えるかを確認

2. **TrackPopupMenuExの動作を確認**
   - 非クライアント領域をクリックした場合、`TrackPopupMenuEx`がどのように動作するかを確認
   - メッセージフックが呼ばれるタイミングを確認

3. **WindowChromeの設定を確認**
   - `WindowChrome`の設定が正しいかを確認
   - `UseAeroCaptionButtons = false`の場合、カスタムのキャプションボタンを使用している
   - これらのボタンが正しく動作するように、設定を確認する

4. **デバッグログを追加**
   - メッセージフックが呼ばれるタイミングをログに出力
   - `WindowChrome`の処理が呼ばれるタイミングをログに出力
   - メッセージの処理順序を確認

